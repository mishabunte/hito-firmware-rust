import { HitoWindow } from "HitoWindow.slint";
import { Router, ScreenEnum } from "Router.slint";

export component LockScreen inherits HitoWindow {
    // Animation properties
    property <bool> key-is-pressed: false;
    is-lockscreen: true; // Indicate this is the lock screen
    property <length> key-offset: 0px;
    property <length> key-offset-start: 0px;
    property <int> lock-frame: 0;
    property <bool> is-unlocked: false;
    property <duration> animation-duration: 60ms;
    property <bool> show-text: true;

    // Key and lock positions (matching C code coordinates)
    property <length> key-start-x: 89px;
    property <length> key-start-y: 90px;
    property <length> lock-x: 184px;
    property <length> lock-y: 90px;
    property <length> unlock-threshold: 100px; // lock-x - key-start-x - 5px
    property <int> first-frame-offset: 24; // For idle animation frame tracking

    property <bool> key_shown: true; // To control key visibility

    back-shown: false; // No back button on lock screen

    // Handle brightness scale visibility changes        show-text = !shown;
    brightness-scale-shown-changed(shown) => {
        show-text = !shown;
    }


    // Title text
    Text {
        text: key-is-pressed ? "Release to unlock" : "Swipe the key";
        font-size: 20px;
        color: black;
        horizontal-alignment: center;
        y: 170px;
        x: 30px;
        wrap: word-wrap;
        width: 260px;
        visible: show-text;
    }

    // Lock sprite with animation frames
    Image {
        source: @image-url("../../res/img/lock.png");
        x: lock-x + first-frame-offset*1px; // Adjusted to align with key
        y: lock-y;
        width: 46px - first-frame-offset*1px;
        height: 34px;
        // Simulate frame animation by changing source-clip-x
        source-clip-x: first-frame-offset;
        source-clip-y: 0;
        source-clip-width: 46 - first-frame-offset;
        source-clip-height: 34;
        visible: key_shown;
        z: 1; // Ensure key is above lock
    }

    // Lock sprite with animation frames
    Image {
        source: @image-url("../../res/img/lock.png");
        x: lock-x;
        y: lock-y;
        width: 46px;
        height: 34px;
        // Simulate frame animation by changing source-clip-x
        source-clip-x: lock-frame * 46 + 46;
        source-clip-y: 0;
        source-clip-width: 46;
        source-clip-height: 34;
        visible: !key_shown;
        z: 1; // Ensure key is above lock
    }

    // Key sprite
    Rectangle {
        x: key-start-x + key-offset + (key-is-pressed ? 0 : key-offset-start);
        y: key-start-y;
        width: 27px;
        height: 34px;
        visible: key_shown;

        Image {
            source: @image-url("../../res/img/lock.png");
            width: 27px;
            height: 34px;
            // Key is at x=322 in the sprite sheet
            source-clip-x: 322;
            source-clip-y: 0;
            source-clip-width: 27;
            source-clip-height: 34; // Hide lock when key is shown
        }
    }

    // Touch area for key interaction - fixed position to avoid coordinate issues
    TouchArea {
        x: key-start-x - 50px; // Slightly larger area for easier interaction
        y: 60px;
        width: 100px; // Full width to capture drag anywhere
        height: 100px;

        property <length> start-x: 0px;
        property <bool> mouse-pressed: false;

        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                debug("Pointer down at " + self.mouse-x / 1px + ", " + self.mouse-y / 1px);
                mouse-pressed = true;
                key-is-pressed = true;
                start-x = self.mouse-x;
            } else if (event.kind == PointerEventKind.up) {
                debug("Pointer up at " + self.mouse-x / 1px + ", " + self.mouse-y / 1px);
                mouse-pressed = false;
                key-is-pressed = false;
                if (key-offset >= unlock-threshold) {
                  debug("Unlock threshold reached");
                    // Trigger unlock animation
                    unlock();
                } else {
                    // Snap back to start
                    key-offset = 0px;
                    key-offset-start = (key-offset-start == -5px) ? 5px : -5px; // Simple back-and-forth
                }
            } else if (event.kind == PointerEventKind.move && mouse-pressed) {
                debug("Pointer move at " + self.mouse-x / 1px + ", " + self.mouse-y / 1px);
                // Calculate offset based on drag distance
                key-offset = min(max(0px, self.mouse-x - start-x), unlock-threshold);
                key-offset-start = key-offset;
                debug("Key offset: " + key-offset / 1px);
            }
        }
    }

    animate key-offset-start {
        duration: (key-is-pressed ? 0ms : 500ms);
        easing: ease-in-out;
    }

    // Start idle animation timer
    Timer {
        interval: 500ms;
        running: !key-is-pressed;
        triggered => {
            key-offset-start = (key-offset-start == -5px) ? 5px : -5px; // Simple back-and-forth
        }
    }

    // Timer for unlock animation
    Timer {
        interval: animation-duration;
        running: is-unlocked && lock-frame <= 5;
        triggered => {
            if (lock-frame < 5) {
                lock-frame += 1;
            } else {
                Router.navigate(ScreenEnum.EnterPin);
            }
        }
    }

    // Functions
    function unlock() {
        debug("Unlocking...");
        key_shown = false;
        is-unlocked = true;
        key-is-pressed = false;
        lock-frame = 0; // Start animation from frame 0
    }
}