import { VerticalBox, HorizontalBox } from "std-widgets.slint";

export component LockScreen inherits Window {
    width: 320px;
    height: 240px;
    background: white;
    
    // Animation properties
    property <bool> key-is-pressed: false;
    property <length> key-offset: 0px;
    property <int> lock-frame: 0;
    property <bool> is-unlocked: false;
    property <duration> animation-duration: 100ms;
    
    // Key and lock positions (matching C code coordinates)
    property <length> key-start-x: 89px;
    property <length> key-start-y: 90px;
    property <length> lock-x: 184px;
    property <length> lock-y: 90px;
    property <length> unlock-threshold: 90px; // lock-x - key-start-x - 5px
    
    // Title text
    VerticalBox {
        alignment: start;
        Text {
            text: key-is-pressed ? "Release to unlock" : "Slide to unlock";
            font-size: 16px;
            color: black;
            horizontal-alignment: center;
            y: 164px;
        }
    }
    
    // Lock sprite with animation frames
    Image {
        source: @image-url("../res/img/lock.png");
        x: lock-x;
        y: lock-y;
        width: 46px;
        height: 34px;
        // Simulate frame animation by changing source-clip-x
        source-clip-x: lock-frame * 46px;
        source-clip-y: 0px;
        source-clip-width: 46px;
        source-clip-height: 34px;
        
        animate source-clip-x {
            duration: animation-duration;
            easing: ease-in-out;
        }
    }
    
    // Key sprite
    Rectangle {
        x: key-start-x + key-offset;
        y: key-start-y;
        width: 27px;
        height: 34px;
        
        Image {
            source: @image-url("../res/img/lock.png");
            width: 27px;
            height: 34px;
            // Key is at x=322 in the sprite sheet
            source-clip-x: 322px;
            source-clip-y: 0px;
            source-clip-width: 27px;
            source-clip-height: 34px;
        }
        
        animate x {
            duration: 200ms;
            easing: ease-out;
        }
    }
    
    // Touch area for key interaction
    Rectangle {
        x: key-start-x - 27px; // Expand touch area left of key
        y: 60px;
        width: 54px; // Double key width
        height: 100px;
        background: transparent;
        
        // Mouse/touch handling
        property <bool> mouse-pressed: false;
        property <length> press-start-x: 0px;
        
        TouchArea {
            clicked => {
                // Simple click - no drag
                if (!mouse-pressed) {
                    key-offset = 0px;
                }
            }
            
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    mouse-pressed = true;
                    key-is-pressed = true;
                    press-start-x = event.position.x;
                } else if (event.kind == PointerEventKind.up) {
                    mouse-pressed = false;
                    if (key-offset >= unlock-threshold) {
                        // Trigger unlock animation
                        unlock();
                    } else {
                        // Snap back to start
                        key-offset = 0px;
                        key-is-pressed = false;
                    }
                } else if (event.kind == PointerEventKind.move && mouse-pressed) {
                    // Calculate offset based on drag distance
                    key-offset = min(max(0px, event.position.x - press-start-x), unlock-threshold);
                }
            }
        }
    }
    
    // Idle animation when key is not pressed
    property <int> idle-animation-frame: 0;
    animate idle-animation-frame {
        duration: 1s;
        iteration-count: -1;
        easing: ease-in-out;
    }
    
    // Update key position for idle animation
    changed idle-animation-frame => {
        if (!key-is-pressed && !is-unlocked) {
            // Simulate breathing animation (0-10-0 pattern from C code)
            if (idle-animation-frame <= 10) {
                key-offset = idle-animation-frame * 1px;
            } else {
                key-offset = (20 - idle-animation-frame) * 1px;
            }
        }
    }
    
    // Start idle animation timer
    Timer {
        interval: 50ms;
        running: !key-is-pressed && !is-unlocked;
        triggered => {
            idle-animation-frame = Math.mod(idle-animation-frame + 1, 20);
        }
    }
    
    // Functions
    function unlock() {
        is-unlocked = true;
        key-is-pressed = false;
        
        // Animate lock frames (0-6)
        Timer {
            interval: animation-duration;
            running: true;
            triggered => {
                if (lock-frame < 6) {
                    lock-frame += 1;
                } else {
                    // Animation complete - trigger unlock callback
                    root.unlocked();
                }
            }
        }
    }
    
    // Callback for when unlock animation completes
    callback unlocked();
}